<h1 id="system-design">System Design<a aria-hidden="true" class="anchor-heading icon-link" href="#system-design"></a></h1>
<p><img src="/assets/images/2023-07-24-21-01-42.png"></p>
<ul>
<li><a href="https://vahid.blog/post/2022-05-05-system-design-interview-cheat-sheet/">source &#x26; elaboration</a></li>
</ul>
<h1 id="early-considerations">Early Considerations<a aria-hidden="true" class="anchor-heading icon-link" href="#early-considerations"></a></h1>
<h2 id="define-scope">Define scope<a aria-hidden="true" class="anchor-heading icon-link" href="#define-scope"></a></h2>
<ol>
<li>Describe the potential surface area of the application, listing out features. Anything is on the table</li>
<li>Constrain the scope with the interviewer
<ul>
<li>What domain primitives do we have?</li>
</ul>
</li>
</ol>
<h2 id="back-of-the-envelope">Back-of-the-envelope<a aria-hidden="true" class="anchor-heading icon-link" href="#back-of-the-envelope"></a></h2>
<ul>
<li>How much main domain data are we storing?
<ul>
<li>ex. if Spotify, how many songs are we storing? If Facebook, how many posts are we storing?</li>
</ul>
</li>
<li>How many users?</li>
</ul>
<h2 id="user-traffic-patterns">User traffic patterns<a aria-hidden="true" class="anchor-heading icon-link" href="#user-traffic-patterns"></a></h2>
<ul>
<li>How many daily active users (DAU)? </li>
<li>How many concurrent users anticipated?</li>
</ul>
<p>How does the typical user use our application?</p>
<ul>
<li><em>Sequential Access Pattern</em> - Users follow a sequential or linear path through the application or website. 
<ul>
<li>ex. in a step-by-step registration process or an e-commerce checkout flow, users move from one page to the next in a predefined sequence.</li>
</ul>
</li>
<li><em>Random Access Pattern</em> - Users access different pages or features of the application in a non-linear, unpredictable manner. They commonly arrive directly from search engine results, bookmarks, or external links.
<ul>
<li>ex. Wikipedia</li>
</ul>
</li>
<li><em>Bursty Traffic Pattern</em> - Occasional spikes in traffic or usage, typically caused by specific events, promotions, or viral content.
<ul>
<li>ex. Ticketmaster pre-sales</li>
</ul>
</li>
<li><em>Daily/Weekly/Seasonal Traffic Pattern</em> - Consistent variations in user traffic based on specific days of the week or times of day. 
<ul>
<li>ex. e-commerce platforms experience higher traffic during holiday seasons.</li>
</ul>
</li>
<li><em>Recurring Traffic Pattern</em> - Users return to the same pages or features regularly 
<ul>
<li>ex. daily news readers or social media platforms.</li>
</ul>
</li>
</ul>
<h2 id="rough-high-level-component-design">Rough high-level component design<a aria-hidden="true" class="anchor-heading icon-link" href="#rough-high-level-component-design"></a></h2>
<p>Once we have all high-level components in place, run through a use-case</p>
<ul>
<li>ex. in Spotify, when a user plays a song, the selected songId is sent from the client to the application server, which sends a query to the relational database to get the song record. Included in the song record is the URL where the <code>.mp3</code> is stored in the blob storage database...</li>
</ul>
<h3 id="database">Database<a aria-hidden="true" class="anchor-heading icon-link" href="#database"></a></h3>
<ul>
<li>SQL or NoSQL?</li>
<li>Rough table design</li>
</ul>
<hr>
<h2 id="fault-tolerance">Fault tolerance<a aria-hidden="true" class="anchor-heading icon-link" href="#fault-tolerance"></a></h2>
<ul>
<li><a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">deploy.distributed.CAP-theorem (Private)</a>: should <em>availability</em> or <em>consistency</em> be prioritized?</li>
<li>automatic leader promotion on failure</li>
<li>RDBMS provides a WAL for improved fault-tolerance</li>
</ul>
<h2 id="scaling">Scaling<a aria-hidden="true" class="anchor-heading icon-link" href="#scaling"></a></h2>
<ul>
<li>Microservice architecture for independent scaling of nodes</li>
<li>Offload non-critical tasks to a job-queue (implemented with something like Redis streams or Apache Kafka)</li>
<li>what is the <code>read:write</code> ratio?</li>
</ul>
<hr>
<h1 id="database-1">Database<a aria-hidden="true" class="anchor-heading icon-link" href="#database-1"></a></h1>
<h2 id="main-app">Main app<a aria-hidden="true" class="anchor-heading icon-link" href="#main-app"></a></h2>
<h3 id="write-heavy-databases">Write-heavy databases<a aria-hidden="true" class="anchor-heading icon-link" href="#write-heavy-databases"></a></h3>
<p>Consider how read-heavy the data in your application is. Write heavy dbs may face scalability issues. </p>
<ul>
<li>For instance, maybe 5x more people are uploading data than are downloading it (a 1:5 read:write ratio). Let's assume 1M writes per day, giving us 5M reads</li>
</ul>
<p>Things to consider</p>
<ul>
<li>Does read data need to be consistent with what was just written? If not, we can cache.</li>
<li>Efficient indexing (recall that indexes slow down write operations)</li>
<li>query optimization necessary</li>
<li>Batching write queries to reduce overhead of establishing connections, executing queries and committing transactions.</li>
<li>offload write operations to an asynchronous processing mechanism (e.g. queue)</li>
<li>implement replication and sharding to distribute writes across multiple replicas</li>
</ul>
<p>If using counters (likes, votes etc.), use distributed counters to distribute load</p>
<p>Can implement caching mechanisms using Redis to reduce load on database</p>
<h3 id="read-heavy-databases">Read-heavy databases<a aria-hidden="true" class="anchor-heading icon-link" href="#read-heavy-databases"></a></h3>
<p>Things to consider</p>
<ul>
<li>Implement efficient indexing on read-heavy sets of data
<ul>
<li>Identify the most frequently executed queries and create indexes on the relevant columns to support them.</li>
</ul>
</li>
<li>Implement caching mechanisms</li>
<li>Use replication to distribute load over multiple replicas</li>
<li>Use load balancing to distribute load over multiple application servers</li>
<li>Consider denormalization to reduce amount of joins needed</li>
<li>Query optimization</li>
</ul>
<h3 id="scaling-1">Scaling<a aria-hidden="true" class="anchor-heading icon-link" href="#scaling-1"></a></h3>
<ul>
<li>Implement read replicas</li>
<li>Vertically scaling the database to upgrade CPU, RAM and storage</li>
<li>Sharding (ie. horizontal scaling) the database can help distribute the load</li>
</ul>
<h3 id="storage">Storage<a aria-hidden="true" class="anchor-heading icon-link" href="#storage"></a></h3>
<ul>
<li>Consider moving a certain subset of the data to cold storage to save on costs</li>
</ul>
<h2 id="authentication">Authentication<a aria-hidden="true" class="anchor-heading icon-link" href="#authentication"></a></h2>
<ul>
<li>Handling large number of registrations and logins will put strain on auth service
<ul>
<li>Consider holding a separate database for our auth service, which will issue JWTs to autenticated users, and will verify JWTs.</li>
</ul>
</li>
</ul>
<h1 id="static-content">Static content<a aria-hidden="true" class="anchor-heading icon-link" href="#static-content"></a></h1>
<ul>
<li>serving static content and handling increased traffic will put a strain on the server and affect the user experience.
<ul>
<li>leverage a CDN to offload static asset serving and improve load times.</li>
</ul>
</li>
</ul>
<h1 id="cache">Cache<a aria-hidden="true" class="anchor-heading icon-link" href="#cache"></a></h1>
<ul>
<li>Managing cache validation and ensuring consistency of content across distributed servers can present challenges
<ul>
<li>Implement cache versioning and cache invalidation strategies (e.g., using cache headers or file hashing) to maintain consistency.</li>
</ul>
</li>
<li>We can cache some of the hot data points that are frequently accessed. Following the 80-20 rule, meaning 20% of hot data points generate 80% of traffic, we would like to cache these 20% data points.
<ul>
<li>ex. if designing a paste-bin clone, cache the top 20% of most accessed pastes.</li>
</ul>
</li>
</ul>
<h1 id="application-servers">Application Server(s)<a aria-hidden="true" class="anchor-heading icon-link" href="#application-servers"></a></h1>
<ul>
<li>if there is concurrently high number of writes to database, make use of message queue like Kafka to decouple the write (eg. Reddit post submission) from the main application </li>
</ul>
<h1 id="scaling-and-high-availability">Scaling and High Availability<a aria-hidden="true" class="anchor-heading icon-link" href="#scaling-and-high-availability"></a></h1>
<ul>
<li>Scaling the system and maintaining high availability across multiple regions can be complex.
<ul>
<li>Employ horizontal scaling by adding more servers and use load balancers to distribute the load.</li>
<li>Implement an automated monitoring and alerting system to help identify and address issues</li>
<li>Employ failover mechanisms to automatically switch to backup systems in case of failure.</li>
</ul>
</li>
<li>Coordinating data replication and ensuring consistency during updates are challenges.
<ul>
<li>Techniques like database replication, data partitioning, and distributed caching can enhance availability and scalability. </li>
</ul>
</li>
</ul>
<hr>
<h2 id="capacity-estimation-and-constraints">Capacity Estimation and Constraints<a aria-hidden="true" class="anchor-heading icon-link" href="#capacity-estimation-and-constraints"></a></h2>
<p>Can users upload as much as they want? For instance, if we were building Instagram, we would want to make efficient storage of photos a top priority.</p>
<h3 id="leveraging-user-expectations">Leveraging User Expectations<a aria-hidden="true" class="anchor-heading icon-link" href="#leveraging-user-expectations"></a></h3>
<p>Have a good understanding of user expectations while designing the application. For instance, in an Instagram-clone, it's not necessary that every user sees the latest content at any given time— we can tolerate some delay. This enables us to retract our focus from strict caching and replication implementations, and instead focus on things that are more important for our system.</p>
<p>How fast do writes need to be? How about reads?</p>
<ul>
<li>For Instagram, fast uploads would not be expected by users. Reads, on the other hand would be expected, since there is a high degree of swiping going on. For this, we'd want to have a more sophisticated caching system in place.</li>
<li>We should keep in mind that web servers have a connection limit before designing our system. If we assume that a web server can have a maximum of 500 connections at any time, then it can’t have more than 500 concurrent uploads or reads. To handle this bottleneck, we can split reads and writes into separate services. We can have dedicated servers for reads and different servers for writes to ensure that uploads don’t hog the system. This has the added benefit of being able to scale each set of services independently.</li>
<li>If users can upload a large amount of data, then efficient management of storage should also be a focus</li>
</ul>
<p>How reliable is your app expected to be?</p>
<ul>
<li>if you are Instagram, your users expect 100% reliability. Therefore, you should store multiple copies of each file so that if one storage server dies, the photo can be retrieved from the other copy present on a different storage server.
<ul>
<li>If we want to have high availability of the system, we need to have multiple replicas of services running in the system so that even if a few services die down, the system remains available and running. Redundancy removes the single point of failure in the system.</li>
</ul>
</li>
</ul>
<h3 id="redundancy">Redundancy<a aria-hidden="true" class="anchor-heading icon-link" href="#redundancy"></a></h3>
<p>All potential bottlenecks and points of failure should be scrutinized. Think of how the system gets more complex as we implement [sharding|db.strategies.sharding]. Now we need a sharding rule to determine in which shard a row is stored. Suppose we implement round robin with <code>recordId % 10</code> to spread out the records evenly. Well, now we have a new problem: we cannot have the shards increment the IDs themselves, since we need the ID first before we can even determine which shard it belongs in. So to solve that, we need some sort of external key generating service. This service can generate IDs, store them in a table (to indicate that it is used) when a new item is created. Each shard can use this service, and we can have perfectly incremented IDs across all shards. However, one last issue arises. This key generation system is now a single point of failure, so we have to iterate further. We could spin up another such key generating service, and split the load between them by having one service give out even-numbered IDs and the other odd-numbered IDs. Finally, we can stick a load balancer in front of them to round-robin the load between them. In case of failure of the even-numbered service, the only consequence is that there will be more odd-numbered IDs; something we probably don't even care about.</p>
<h3 id="back-of-the-envelope-estimations">Back-of-the-envelope Estimations<a aria-hidden="true" class="anchor-heading icon-link" href="#back-of-the-envelope-estimations"></a></h3>
<p>From there, assume that each item is 10KB, so we need to store 10GB per day. If we want to store this data for an average of 10 years then we need storage capacity of 36TB.</p>
<ul>
<li>To keep some margin, we will assume a 70% capacity model (meaning we don’t want to use more than 70% of our total storage capacity at any point), which raises our storage needs to 51.4TB.</li>
</ul>
<p>New items per second:</p>
<ul>
<li>1M / (24 hours * 3600 seconds) ~= 12 pastes/sec
results in
120KB of ingress per second.</li>
<li>12 * 10KB => 120 KB/s</li>
</ul>
<p>Reads per second:</p>
<ul>
<li>5M / (24 hours * 3600 seconds) ~= 58 reads/sec
results in
total data egress (sent to users) will be 0.6 MB/s.</li>
<li>58 * 10KB => 0.6 MB/s</li>
</ul>
<p>This number of records totals 3.6 Billion in 10 years. Since 6 random <a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">base64 encoding (Private)</a> ([A-Z, a-z, 0-9, ., -]) can be used to generate 68.7 billion unique strings, this should be sufficient for uniqueness.</p>
<p>Since we have 5M read requests per day, to cache 20% of these requests, we would need:</p>
<ul>
<li>0.2 <em> 5M </em> 10KB ~= 10 GB</li>
</ul>
<hr>
<h2 id="dendron-notes-to-review">Dendron notes to review<a aria-hidden="true" class="anchor-heading icon-link" href="#dendron-notes-to-review"></a></h2>
<ul>
<li><a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">auth.tokens.jwt (Private)</a></li>
<li><a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">api.gateway (Private)</a></li>
<li><a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">deploy.distributed.CAP-theorem (Private)</a></li>
</ul>
<h2 id="e-resources">E Resources<a aria-hidden="true" class="anchor-heading icon-link" href="#e-resources"></a></h2>
<ul>
<li><a href="https://systemdesign.one/slack-architecture/">Slack architecture</a></li>
<li><a href="https://systemdesign.one/back-of-the-envelope/">Back-of-the-envelope analysis</a></li>
</ul>
<h2 id="resources">Resources<a aria-hidden="true" class="anchor-heading icon-link" href="#resources"></a></h2>
<ul>
<li><a href="https://github.com/donnemartin/system-design-primer">System Design Primer</a></li>
<li><a href="https://systemdesign.one/distributed-counter-system-design/">Distributed counter design</a></li>
<li><a href="https://systemdesign.one/real-time-presence-platform-system-design/">Real-time presence design</a></li>
<li><a href="https://systemdesign.one/live-comment-system-design/">Live comment system design</a></li>
<li><a href="https://systemdesign.one/leaderboard-system-design/">Leaderboard system design</a></li>
<li><a href="https://systemdesign.one/system-design-pastebin/">Pastebin system design</a></li>
<li><a href="https://systemdesign.one/url-shortening-system-design/">URL shortening system design</a></li>
<li><a href="https://systemdesign.one/what-is-service-discovery/">Service Discovery</a></li>
<li><a href="https://hackingthesystemsdesigninterview.com/">Various system designs</a></li>
<li><a href="https://github.com/puncsky/system-design-and-architecture">System Design and Architecture</a></li>
<li><a href="https://systemdesign.one/system-design-interview-cheatsheet">System design cheatsheet</a></li>
<li><a href="https://www.youtube.com/@IGotAnOffer-Engineering">Youtube series: System Design</a></li>
</ul>